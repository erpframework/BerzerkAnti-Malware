using BerzerkAPI.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using Microsoft.Win32;
using System.IO;

namespace BerzerkAPI.IO
{
    public static class Heuristic
    {
        // List of heuristic rule sets 
        private static HeuristicEngine.HeuristicRuleSet Rules = new HeuristicEngine.HeuristicRuleSet(); 

        public static Signature Analyze(string filePath)
        {
            //throw new Exception("Not implemented yet...");
            try
            {
                // create references to the file 
                if (!System.IO.File.Exists(filePath))
                    return null;

                if (!File.isScannable(filePath))
                    return null; 

                var fileInfo = new System.IO.FileInfo(filePath);
                int threatLevel = Rules.calculateThreatLevel(fileInfo).ThreatLevel; 

                // Check the heuristic fules 
               if(threatLevel >= 70)
                {
                    return new Signature()
                    {
                        DateFound = DateTime.Now.ToShortDateString(),
                        Definition = "HEURISTIC",
                        Id = threatLevel
                    };
                }

                return null; 
            }
            catch (Exception ex)
            {
#if DEBUG
                Console.WriteLine(ex.Message); 
#endif
                // throw new Exception("Unable to analyze file."); 
                return null; 
            }
        }
    }
    namespace HeuristicEngine
    {
        public abstract class HueristicEvaluation
        {
            public abstract Analysis calculateThreatLevel(System.IO.FileInfo fileInfo);
        }

        public class HeursticRuleSet2 : HeuristicEngine.HueristicEvaluation
        {
            public override Analysis calculateThreatLevel(FileInfo fileInfo)
            {
                throw new NotImplementedException();
            }
        }

        public class HeuristicRuleSet : HeuristicEngine.HueristicEvaluation
        {
            public bool CheckStartup { get; set; } = true;
            public List<string> Rules = new List<string>(); 

            public HeuristicRuleSet()
            {
                CheckStartup = true;
                Rules = new List<string>();

                #region BetaTestRules 
                Rules.Add("\\appdata\\");
                Rules.Add("winlogon");
                Rules.Add("stub");
                Rules.Add("server.exe");
                Rules.Add("trojan.exe"); 
                Rules.Add("new folder");
                Rules.Add("\\appdata\\windows\\update");
                Rules.Add("\\appdata\\roaming\\microsoft\\windows");
                Rules.Add("\\appdata\\local\\microsoft\\");
                Rules.Add("explorer.exe");
                Rules.Add("svchost.exe");
                Rules.Add("scvhost.exe");
                #endregion
            }

            public HeuristicRuleSet(bool checkStartup, List<string> rules)
            {
                this.CheckStartup = checkStartup;
                this.Rules = rules;
            }

            public string isStartUp(string filePath)
            {
                string result = string.Empty;
                string[] paths = new string[] { "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce", "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run" };

                foreach (string path in paths)
                {
                    try
                    {
                        // Do current user 
                        RegistryKey hkcu = Registry.CurrentUser.OpenSubKey(path, true);

                        foreach (string subKey in hkcu.GetValueNames())
                        {
                            // get key value 
                            string value = (string)hkcu.GetValue(subKey, string.Empty);

                            if (value.ToLower().Contains(filePath.ToLower()))
                            {
                                return value;
                            }
                        }

                        // Do local machine 
                        RegistryKey hklm = Registry.LocalMachine.OpenSubKey(path);
                        foreach (string subKey in hklm.GetValueNames())
                        {
                            // get key value 
                            string value = (string)hklm.GetValue(subKey, string.Empty);

                            if (value.ToLower().Contains(filePath.ToLower()))
                            {
                                return value;
                            }
                        }

                    }
                    catch (Exception ex)
                    {
                        // Console.WriteLine(ex.Message);
                    }
                }

                return result;
            }

            public int isRunning(string filePath)
            {
                try
                {
                    foreach (var p in System.Diagnostics.Process.GetProcesses())
                    {
                        if (API.NativeMethods.GetExecutablePath(p) == filePath)
                            return p.Id;
                    }

                    return -1;
                }
                catch (Exception ex)
                {
                    return -1;
                }
            }

            //public int calculateThreatLevel(System.IO.FileInfo fileInfo)
            //{
            //    int threatLevel = 0;

            //    string startup = isStartUp(fileInfo.FullName);
            //    int running = isRunning(fileInfo.FullName);

            //    if (startup != string.Empty && running != -1)
            //    {
            //        threatLevel += 50;
            //    }
            //    else if (startup != string.Empty)
            //    {
            //        threatLevel += 15;
            //    }
            //    else if (running != -1)
            //    {
            //        threatLevel += 15;
            //    }

            //    // Check for well known folder and file names 
            //    foreach (var r in this.Rules)
            //    {
            //        if (fileInfo.FullName.ToLower().Contains(r.ToLower()))
            //        {
            //            threatLevel += 15;
            //        }
            //    }

            //    // check file properties 
            //    if ((fileInfo.Attributes & System.IO.FileAttributes.Hidden) != 0)
            //    {
            //        threatLevel += 15;
            //    }

            //    // Check root directory properties 
            //    var dirInfo = new System.IO.DirectoryInfo(System.IO.Path.GetDirectoryName(fileInfo.FullName));
            //    if ((dirInfo.Attributes & System.IO.FileAttributes.Hidden) != 0)
            //    {
            //        threatLevel += 15;
            //    }

            //    // file sizes 
            //    if (fileInfo.Length < 128 * 1024)
            //        threatLevel += 15;
            //    else if (fileInfo.Length < 256 * 1024)
            //        threatLevel += 10;
            //    else if (fileInfo.Length < 512 * 1024)
            //        threatLevel += 5;


            //    //double calc = 95 + (Rules.Count * 15);
            //    //threatLevel = (int)((threatLevel) / calc * 100.00);

            //    return threatLevel;
            //}

            public override Analysis calculateThreatLevel(FileInfo fileInfo)
            {
                Analysis result = new HeuristicEngine.Analysis() { fileInfo = fileInfo };
                int threatLevel = 0;

                string startup = isStartUp(fileInfo.FullName);
                int running = isRunning(fileInfo.FullName);

                if (startup != string.Empty && running != -1)
                {
                    threatLevel += 50;
                    result.isStartUp = true;
                    result.ProcessId = running;
                }
                else if (startup != string.Empty)
                {
                    threatLevel += 15;
                    result.isStartUp = true; 
                }
                else if (running != -1)
                {
                    threatLevel += 15;
                    result.ProcessId = running; 
                }

                // Check for well known folder and file names 
                foreach (var r in this.Rules)
                {
                    if (fileInfo.FullName.ToLower().Contains(r.ToLower()))
                    {
                        threatLevel += 15;
                    }
                }

                // check file properties 
                if ((fileInfo.Attributes & System.IO.FileAttributes.Hidden) != 0)
                {
                    threatLevel += 15;
                }

                // Check root directory properties 
                var dirInfo = new System.IO.DirectoryInfo(System.IO.Path.GetDirectoryName(fileInfo.FullName));
                if ((dirInfo.Attributes & System.IO.FileAttributes.Hidden) != 0)
                {
                    threatLevel += 15;
                }

                // file sizes 
                if (fileInfo.Length < 128 * 1024)
                    threatLevel += 15;
                else if (fileInfo.Length < 256 * 1024)
                    threatLevel += 10;
                else if (fileInfo.Length < 512 * 1024)
                    threatLevel += 5;

                result.ThreatLevel = threatLevel;

                return result; 
            }
        }

        public class Analysis
        {
            public System.IO.FileInfo fileInfo { get; set; }
            public int ThreatLevel { get; set; }
            public int ProcessId { get; set; }
            public bool isStartUp { get; set; }
        }
    } 
}
