using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using BerzerkAPI.Models;
using BerzerkAPI.Controllers;

namespace BerzerkAPI.Analyzers
{
    /*
     * Name: PatternAnalyzer
     * Date: 01/10/2016
     * Developer: Jordan Hook 
     * Descroption:
     *              The pattern analzyer is a helper library that contains methods for pattern scanning byte arrays in various types of objects
     *              such as processes and files 
     */
    public class PatternAnalyzer
    {
        //public static Signature AnyalyzeByteArrayv2(byte[] data, SignatureController patterns)
        //{
        //    // Temp variable to count matching bytes with 
        //    int startIdx = 0;
        //    byte[] pattern; 

        //    // Loop through the data array 
        //    for(int i = 0; i < data.Length; i++)
        //    {
        //        // check check each pattern for a start on each byte 
        //        for(int j = 0; j < patterns.Signatures.Count; j++)
        //        {
        //            // get the current pattern 
        //            pattern = patterns.Signatures[j].Pattern;

        //            // Pattern is too big to check 
        //            if((data.Length - i) - pattern.Length <= 0)
        //            {
        //                // Move to next index... 
        //                break; 
        //            }
        //            else
        //            {

        //                if(i + (pattern.Length - 1) >= data.Length)
        //                {
        //                    Console.WriteLine("ERROR LOCATED.."); 
        //                }
        //                // Check for matching first and last byte of apttern 
        //                if(pattern[0] == data[i] && pattern[pattern.Length - 1] == data[i + (pattern.Length - 1)])
        //                {
        //                    // matching first and last byte... enter a new loop to check for all matching bytes
        //                    for(startIdx = 1; startIdx < pattern.Length; startIdx++)
        //                    {
        //                        // skip null bytes in pattern 
        //                        if (pattern[startIdx] == 0)
        //                            continue;
        //                        // Compare all bytes 
        //                        else if(pattern[startIdx] != data[i + startIdx])
        //                        {
        //                            // If a non matching byte is found, break 
        //                            break;
        //                        }
        //                    }

        //                    // If the pattern was found (so all bytes matched) 
        //                    if (startIdx == pattern.Length)
        //                        // Return the found pattern
        //                        return patterns.Signatures[j]; 
        //                }
        //            }
        //        }
        //    }

        //    // If we reached here, no match was found 
        //    return null;
        //}

        /// <summary>
        /// Searches a byte array for matching patterns
        /// </summary>
        /// <param name="data">The byte array to search</param>
        /// <param name="patterns">The list of patterns to search for</param>
        /// <returns>A matching malware signature or null if nothing is found</returns>
        public static Signature AnalyzeByteArray(byte[] data, SignatureController patterns)
        {
            // Get all signatures that are a valid length to search for 
            // Signatures must be less than or equal to the length of data 
            var validSignatures = patterns.Signatures.Where(s => s.Pattern.Length < data.Length);

            // Now loop through all the valid signatures and compare them agaisnt the data looking for a match 
            foreach (Signature s in patterns.Signatures)
            {
                //// Check each signature, if it returns anything other then -1, then it's a match 
                //if (LinearSearch(ref data, s.Pattern) != -1)
                //    // When a match is found, return the signature
                //    return s;
                if (s.Pattern.Length <= 8)
                {
                    if(LinearSearch(ref data, s.Pattern) != -1)
                    return s;
                }
                else if (SimpleBoyerMooreSearch(data, s.Pattern) != -1)
                //else if(BoyerMooreHorspool(data, s.Pattern) != -1)
                    return s;
            }

            // If no matches were found, return null 
            return null;
        }

        /// <summary>
        /// Performs a linear search on an array of data
        /// </summary>
        /// <param name="haystack">The data to search</param>
        /// <param name="needle">The pattern to search for</param>
        /// <returns>First matching index of the pattern or -1 if not found</returns>
        private static int LinearSearch(ref byte[] haystack, byte[] needle)
        {
            // A temporary variable to help searches 
            int startIndex;

            // Loop through every byte in the haystack - the length of the needle (we need to match a full needle to the haystack) 
            for (int i = 0; i < haystack.Length - needle.Length; i++)
            {
                // Check if the first index in the needle matches the current byte of the haystack 
                //if(haystack[i] == needle[0] && haystack[i + (needle.Length - 1)] == needle[needle.Length - 1])
                if (haystack[i] == needle[0] && haystack[i + (needle.Length / 2)] == needle[needle.Length / 2] && haystack[i + (needle.Length - 1)] == needle[needle.Length - 1])
                //if (QuickMatch(ref haystack, i, ref needle)) // <--  a function I am currently developing 
                {
                    //return i;

                    // Loop through the rest of the needle for a match 
                    for (startIndex = 1; startIndex < needle.Length - 1; startIndex++)
                    {
                        // Check if the current index of the needle is a null / 0, if it is, it's a special byte we can skip 
                        if (needle[startIndex] == 0)
                            continue;
                        // Else, check to see if the needle continues to match the haystack 
                        else if (haystack[i + startIndex] != needle[startIndex])
                            // If the pattern stops matching, break the loop to disrupt the count of matching bytes 
                            //startIndex = needle.Length + 1;
                            break;
                    }

                    // After the check is complete, we need to see if the whole pattern match 
                    if (startIndex == needle.Length - 1)
                        // If we found the correct number of matching bytes... return the index of the match 
                        return i;
                    ////else
                    ////i += startIndex - 1;
                }
            }

            // No match was found, return -1 
            return -1;
        }

        static int SimpleBoyerMooreSearch(byte[] haystack, byte[] needle)
        {
            int[] lookup = new int[256];
            for (int i = 0; i < lookup.Length; i++) { lookup[i] = needle.Length; }

            for (int i = 0; i < needle.Length; i++)
            {
                lookup[needle[i]] = needle.Length - i - 1;
            }

            int index = needle.Length - 1;
            var lastByte = needle.Last();
            while (index < haystack.Length)
            {
                var checkByte = haystack[index];
                if (haystack[index] == lastByte)
                {
                    bool found = true;
                    for (int j = needle.Length - 2; j >= 0; j--)
                    {
                        if (haystack[index - needle.Length + j + 1] != needle[j])
                        {
                            found = false;
                            break;
                        }
                    }

                    if (found)
                        return index - needle.Length + 1;
                    else
                        index++;
                }
                else
                {
                    index += lookup[checkByte];
                }
            }
            return -1;
        }
    }
}
