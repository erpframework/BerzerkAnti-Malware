using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

//new...
using BerzerkAPI.Analyzers;
using BerzerkAPI.Controllers;
using BerzerkAPI.Models;

//Also new... 
using System.IO;
namespace BerzerkAPI.IO
{
    /*
     * Name: File Libaray 
     * Date: 12/10/2016
     * Developer:Jordan Hook
     * Description: 
     *              The file library provides various functions to perform scans and collect information 
     *              about files systems. 
     */ 
    public static class File
    {
        /// <summary>
        /// Performs a scan on the provided file
        /// </summary>
        /// <param name="filePath">The file to scan.</param>
        /// <param name="Signatures">The signature controller</param>
        /// <param name="cached">The cache controller</param>
        /// <returns>Null or a signature</returns>
        public static ScanResultArgs ScanFile(string filePath, ref SignatureController Signatures, ref CachedController cached)
        {
            try
            {
                // *** NEW ***
                // Create a new filestream to read the file with 
                FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read);

                // Before performing any kind of scan, we need to make sure it's a executable file 
                if (!isScannable(filePath))
                {
                    // If it's not, return null and theres no point of scanning it 
                    //return null; 
                    return new ScanResultArgs() { Detection = null, Size = fs.Length };
                }

                // Determine if the file is too large to scan based on settings 
                if (fs.Length > Settings.MaxFileSize)
                {
                    // If so, just return null... 
                    return new ScanResultArgs() { Detection = null, Size = fs.Length };
                }

                // ***********


                // Some local variables to store scan information in 
                string hash = string.Empty; 

                // If a cache database is supplied with the scan request 
                if (cached != null)
                {
                    // Try to obtain a md5 hash from the file (see exception below for possible issues) 
                    //hash = MD5.FromFile(filePath);
                    hash = MD5.FromFile(fs);
                    
                    // Check the file cache to see if the file has already been scanned 
                    var found = cached.GetById(hash); 

                    // If a cached item was found in the db
                    if(found != null)
                    {
                        // Return the matching signature if any... 
                        //return Signatures.GetById(found.SignatureId); 
                        return new ScanResultArgs() { Detection = Signatures.GetById(found.SignatureId), Size = fs.Length };
                    }
                }

                // Either the file cache database is not being used or no entry was found 
                // So we must perform a new scan on the file

                // Determine architecture 
                int _buffer = 32; 
                if(Environment.Is64BitOperatingSystem)
                {
                    _buffer = 64;
                }

                byte[] buffer = new byte[1024 * _buffer]; // Scan in 32kb increments 
                int read = -1; // count how many bytes have been read on each read here 

                // Make sure our buffer isn't bigger than the file 
                if(buffer.Length > fs.Length)
                {
                    // If it is, resize the buffer accordinly 
                    buffer = new byte[fs.Length]; 
                }

                // While there is data to read in the file stream 
                while(read != 0)
                {
                    // Attempt to read the buffered amount.. 
                    read = fs.Read(buffer, 0, buffer.Length);

                    // If the buffered amount if greater than the amount read... 
                    // Lets shrink buffer to speed up the pattern search 
                    if(read < buffer.Length)
                    {
                        Array.Resize(ref buffer, read); 
                    }

                    // Analyze the buffer with the pattern analyzer 
                    var result = PatternAnalyzer.AnalyzeByteArray(buffer, Signatures); 

                    // If the result is not null... a detection was found 
                    if(result != null)
                    {
                        // Since a detection was found we may need to update our cached database 
                        if(cached != null)
                        {
                            // Enter the detected threat
                            cached.AddOne(new CachedFile()
                            {
                                Id = hash,
                                SignatureId = result.Id
                            });

                        }

                        // We already detected the threat so we do not need to read any more..
                        fs.Dispose();

                        // return the threat
                        return new ScanResultArgs() { Detection = result, Size = fs.Length };
                    }
                }

                // We finished reading the file and no threat was detected 
                // Time to clean and and may be log to cache 

                // Close up the file stream
                fs.Close();
                fs.Dispose();

                // clear buffer 
                buffer = null; 

                // If the cache database is enable 
                if(cached != null)
                {
                    // Add the clean cache file to the database 
                    cached.AddOne(new CachedFile()
                    {
                        Id = hash,
                        SignatureId = -1
                    });

                }

                // Return a clean scan 
                return new ScanResultArgs() { Detection = null, Size = fs.Length};

            }
            catch (Exception ex) // for debugging purposes
            {
#if DEBUG
                Console.WriteLine(ex.Message);
                throw new Exception(String.Format("Unable to scan file at location {0}. File may be use or additional rights may be required.", filePath)); 
#endif
                // Throw an exception with info about what may have caused the error. 
                throw new Exception(String.Format("Unable to scan file at location {0}. File may be use or additional rights may be required.", filePath)); 
                //return new ScanResultArgs() { Detection = null, Size = 0 };
            }
        }

        /// <summary>
        /// Generates a queue of files
        /// </summary>
        /// <param name="root">The initial directory of the queue</param>
        /// <param name="recursive">Do you want to search folders within the root directoy</param>
        /// <returns>A queue of files to scan </returns>
        public static Queue<string> CreateFileQueue(string root, bool recursive)
        {
            // Create a new queue to store all file paths in 
            Queue<string> fileList = new Queue<string>();

            try
            {
                // Get all files in the initial directory 
                foreach (string file in Directory.GetFiles(root))
                {
                    // Add each of the files to the queue 
                    fileList.Enqueue(file);
                }
            }
            catch (Exception ex)
            {
#if DEBUG
                Console.WriteLine(ex.Message);
#endif
            }

            // Check if we are to check all the child directories as well 
            if(recursive)
            {
                try
                {
                    // Get all the directories in the root dir 
                    foreach (string dir in Directory.GetDirectories(root))
                    {
                        // Create a queue with al the child directories 
                        Queue<string> children = CreateFileQueue(dir, recursive);

                        // Merge the child file sinto our main queue 
                        while (children.Count > 0)
                        {
                            // Copy over each file 
                            fileList.Enqueue(children.Dequeue());
                        }
                    }
                }
                catch(Exception ex)
                {
#if DEBUG
                    Console.WriteLine(ex.Message);
#endif
                }
            }

            // Return our queue 
            return fileList;
        }

        public static bool isScannable(string filePath)
        {
            //// Check agaisnt all scannable file types 
            //foreach(string ext in Settings.ScannableFiles)
            //{
            //    // Check if the extension is a valid file that we can scan 
            //    if(filePath.ToLower().EndsWith(ext))
            //    {
            //        // Return true 
            //        return true; 
            //    }
            //}

            //// No match was found... probably not a scannable file 
            //return false; 
            string ext = filePath.ToLower().Remove(0, filePath.LastIndexOf("."));

            return Settings.ScannableFiles.Contains(ext);
        }
    }

    public struct ScanResultArgs
    {
        public decimal Size { get; set; }
        public Signature Detection { get; set; }
    }
}
