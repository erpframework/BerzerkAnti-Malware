using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using BerzerkAPI.Models;
using BerzerkAPI.Controllers;
using System.Runtime.InteropServices;
using System.Threading;

namespace BerzerkAPI.Analyzers
{
    /*
     * Name: PatternAnalyzer
     * Date: 01/10/2016
     * Developer: Jordan Hook 
     * Descroption:
     *              The pattern analzyer is a helper library that contains methods for pattern scanning byte arrays in various types of objects
     *              such as processes and files 
     */
    public class PatternAnalyzer
    {
        // public static AhoCorasick.Trie<byte, Signature> matcher; 

        /// <summary>
        /// Searches a byte array for matching patterns
        /// </summary>
        /// <param name="data">The byte array to search</param>
        /// <param name="patterns">The list of patterns to search for</param>
        /// <returns>A matching malware signature or null if nothing is found</returns>
        public static Signature AnalyzeByteArray(byte[] data, SignatureController patterns)
        {
            var found = patterns.Analyzer.SearchFirst(data);

            if (found.Index == -1)
            {
                return null;
            }
            else
            {
                return found.Match;
            }

            //var found = matcher.Find(data);

            //if (found.Count() > 0)
            //{
            //    return found.ElementAt(0);
            //}

            ////////if (matcher.Find(data).Any())
            ////////{
            ////////    return new Signature() { Definition = "TEST" };
            ////////}

            //return null;

            //var result = matcher.Find(data);

            //if (result.Count() == 0)
            //    return null;
            //else
            //    return result.ElementAt(0); 

            // Get all signatures that are a valid length to search for 
            // Signatures must be less than or equal to the length of data 
            //var validSignatures = patterns.Signatures.Where(s => s.Pattern.Length < data.Length);

            //// Now loop through all the valid signatures and compare them agaisnt the data looking for a match 
            foreach (Signature s in patterns.Signatures)
            {
                // Based on the size of the pattern, run an appropriate algorithm 
                if (s.Pattern.Length <= 8)
                {
                    // Shorter algorithms will run linear searches 
                    if (LinearSearch(ref data, s.Pattern) != -1)
                        return s;
                    //if (find(data, data.Length, s.Pattern, s.Pattern.Length) != -1)
                    //    return s;
                }
                // Longer patterns will perform a BoyerMooreSearch 
                else if (SimpleBoyerMooreSearch(data, s.Pattern) != -1)
                    return s;
                //else if (KnuthMorrisPrat(data, s.Pattern) != -1)
                //{
                //    return s;
                //}
                //else if (boyerMoore(data, data.Length, s.Pattern, s.Pattern.Length) != -1)
                //    return s;
            }

            //foreach(Signature s in patterns.Signatures)
            //{
            //    if(data.Length <= 32768)
            //    {
            //        if (LinearSearch(ref data, s.Pattern) != -1)
            //            return s;
            //    }
            //    else
            //    {
            //        if (SimpleBoyerMooreSearch(data, s.Pattern) != -1)
            //            return s;
            //    }
            //}

            // If no matches were found, return null 
            return null;
        }

        [DllImport("NativeLib.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern int find(byte[] haystack, int hsize, byte[] needle, int nsize);

        [DllImport("NativeLib.dll", CallingConvention = CallingConvention.Cdecl)]
        static extern int boyerMoore(byte[] haystack, int hsize, byte[] needle, int nsize);

        /// <summary>
        /// Performs a linear search on an array of data
        /// </summary>
        /// <param name="haystack">The data to search</param>
        /// <param name="needle">The pattern to search for</param>
        /// <returns>First matching index of the pattern or -1 if not found</returns>
        private static int LinearSearch(ref byte[] haystack, byte[] needle)
        {
            if (needle.Length > haystack.Length)
                return -1; 

            // A temporary variable to help searches 
            int startIndex;

            // Loop through every byte in the haystack - the length of the needle (we need to match a full needle to the haystack) 
            for (int i = 0; i < haystack.Length - needle.Length; i++)
            {
                // Check if the first index in the needle matches the current byte of the haystack 
                //if(haystack[i] == needle[0] && haystack[i + (needle.Length - 1)] == needle[needle.Length - 1])

                // Check the middle, begin and end locations for matches 
                if (haystack[i] == needle[0] && haystack[i + (needle.Length / 2)] == needle[needle.Length / 2] && haystack[i + (needle.Length - 1)] == needle[needle.Length - 1])
                //if (QuickMatch(ref haystack, i, ref needle)) // <--  a function I am currently developing 
                {
                    //return i;

                    // Loop through the rest of the needle for a match 
                    for (startIndex = 1; startIndex < needle.Length - 1; startIndex++)
                    {
                        // Check if the current index of the needle is a null / 0, if it is, it's a special byte we can skip 
                        if (needle[startIndex] == 0)
                            continue;
                        // Else, check to see if the needle continues to match the haystack 
                        else if (haystack[i + startIndex] != needle[startIndex])
                            // If the pattern stops matching, break the loop to disrupt the count of matching bytes 
                            //startIndex = needle.Length + 1;
                            break;
                    }

                    // After the check is complete, we need to see if the whole pattern match 
                    // *** - 1 added to needle.length to make up for the adjustment to the for loop (-1), due to the pivots check 
                    if (startIndex == needle.Length - 1)
                        // If we found the correct number of matching bytes... return the index of the match 
                        return i;
                    ////else
                    ////i += startIndex - 1;
                }
            }

            // No match was found, return -1 
            return -1;
        }

        static int SimpleBoyerMooreSearch(byte[] haystack, byte[] needle)
        {
            if (needle.Length > haystack.Length)
                return -1; 

            int[] lookup = new int[256];
            for (int i = 0; i < lookup.Length; i++) { lookup[i] = needle.Length; }

            for (int i = 0; i < needle.Length; i++)
            {
                lookup[needle[i]] = needle.Length - i - 1;
            }

            int index = needle.Length - 1;
            var lastByte = needle.Last();
            while (index < haystack.Length)
            {
                var checkByte = haystack[index];
                if (haystack[index] == lastByte)
                {
                    bool found = true;
                    for (int j = needle.Length - 2; j >= 0; j--)
                    {
                        if (haystack[index - needle.Length + j + 1] != needle[j])
                        {
                            found = false;
                            break;
                        }
                    }

                    if (found)
                        return index - needle.Length + 1;
                    else
                        index++;
                }
                else
                {
                    index += lookup[checkByte];
                }
            }
            return -1;
        }

        public static int KnuthMorrisPrat(byte[] str, byte[] pat)
        {
            int M = pat.Length;
            int N = str.Length;
            int i = 0;
            int j = 0;
            int[] lps = new int[M];

            ComputeLPSArray(pat, M, lps);

            while (i < N)
            {
                if (pat[j] == str[i])
                {
                    j++;
                    i++;
                }

                if (j == M)
                {
                    return i - j;
                    j = lps[j - 1];
                }

                else if (i < N && pat[j] != str[i])
                {
                    if (j != 0)
                        j = lps[j - 1];
                    else
                        i = i + 1;
                }
            }

            return -1;
        }

        private static void ComputeLPSArray(byte[] pat, int m, int[] lps)
        {
            int len = 0;
            int i = 1;

            lps[0] = 0;

            while (i < m)
            {
                if (pat[i] == pat[len])
                {
                    len++;
                    lps[i] = len;
                    i++;
                }
                else
                {
                    if (len != 0)
                    {
                        len = lps[len - 1];
                    }
                    else
                    {
                        lps[i] = 0;
                        i++;
                    }
                }
            }
        }
    }

    


}
