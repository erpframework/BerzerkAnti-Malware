using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

//new...
using BerzerkAPI.Analyzers;
using BerzerkAPI.Controllers;
using BerzerkAPI.Models;

//Also new... 
using System.IO;


namespace BerzerkAPI.IO
{
    /*
     * Name: File Libaray 
     * Date: 12/10/2016
     * Developer:Jordan Hook
     * Description: 
     *              The file library provides various functions to perform scans and collect information 
     *              about files systems. 
     */ 
    public static class File
    {
        public static Signature ScanFile(string filePath, ref  SignatureController Signatures, ref CachedController cached)
        {
            try
            {
                // *** NEW ***

                // Before performing any kind of scan, we need to make sure it's a executable file 
                if(!isScannable(filePath))
                {
                    // If it's not, return null and theres no point of scanning it 
                    return null; 
                }

                // ***********


                // Some local variables to store scan information in 
                string hash = string.Empty; 

                // If a cache database is supplied with the scan request 
                if (cached != null)
                {
                    // Try to obtain a md5 hash from the file (see exception below for possible issues) 
                    hash = MD5.FromFile(filePath);

                    // Check the file cache to see if the file has already been scanned 
                    var found = cached.GetById(hash); 

                    // If a cached item was found in the db
                    if(found != null)
                    {
                        // Return the matching signature if any... 
                        return Signatures.GetById(found.SignatureId); 
                    }
                }

                // Either the file cache database is not being used or no entry was found 
                // So we must perform a new scan on the file

                // Create a new filestream to read the file with 
                FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read);
                byte[] buffer = new byte[1024 * 32]; // Scan in 32kb increments 
                int read = -1; // count how many bytes have been read on each read here 

                // Determine if the file is too large to scan based on settings 
                if(fs.Length > Settings.MaxFileSize)
                {
                    // If so, just return null... 
                    return null; 
                }

                // Make sure our buffer isn't bigger than the file 
                if(buffer.Length > fs.Length)
                {
                    // If it is, resize the buffer accordinly 
                    buffer = new byte[fs.Length]; 
                }

                // While there is data to read in the file stream 
                while(read != 0)
                {
                    // Attempt to read the buffered amount.. 
                    read = fs.Read(buffer, 0, buffer.Length);

                    // If the buffered amount if greater than the amount read... 
                    // Lets shrink buffer to speed up the pattern search 
                    if(read < buffer.Length)
                    {
                        Array.Resize(ref buffer, read); 
                    }

                    // Analyze the buffer with the pattern analyzer 
                    var result = PatternAnalyzer.AnalyzeByteArray(buffer, Signatures); 

                    // If the result is not null... a detection was found 
                    if(result != null)
                    {
                        // Since a detection was found we may need to update our cached database 
                        if(cached != null)
                        {
                            // Enter the detected threat
                            cached.AddOne(new CachedFile()
                            {
                                Id = hash,
                                SignatureId = result.Id
                            });

                        }

                        // We already detected the threat so we do not need to read any more..
                        fs.Dispose();

                        // return the threat
                        return result;
                    }
                }

                // We finished reading the file and no threat was detected 
                // Time to clean and and may be log to cache 

                // Close up the file stream
                fs.Close();
                fs.Dispose();

                // clear buffer 
                buffer = null; 

                // If the cache database is enable 
                if(cached != null)
                {
                    // Add the clean cache file to the database 
                    cached.AddOne(new CachedFile()
                    {
                        Id = hash,
                        SignatureId = -1
                    });

                }

                // Return a clean scan 
                return null; 

            }
            catch (Exception) // for debugging purposes
            {
                // Throw an exception with info about what may have caused the error. 
                throw new Exception(String.Format("Unable to scan file at location {0}. File may be use or additional rights may be required.", filePath)); 
            }
        }

        /// <summary>
        /// Generates a queue of files
        /// </summary>
        /// <param name="root">The initial directory of the queue</param>
        /// <param name="recursive">Do you want to search folders within the root directoy</param>
        /// <returns>A queue of files to scan </returns>
        public static Queue<string> CreateFileQueue(string root, bool recursive)
        {
            // Create a new queue to store all file paths in 
            Queue<string> fileList = new Queue<string>(); 

            // Get all files in the initial directory 
            foreach(string file in Directory.GetFiles(root))
            {
                // Add each of the files to the queue 
                fileList.Enqueue(file); 
            }

            // Check if we are to check all the child directories as well 
            if(recursive)
            {
                // Get all the directories in the root dir 
                foreach(string dir in Directory.GetDirectories(root))
                {
                    // Create a queue with al the child directories 
                    Queue<string> children = CreateFileQueue(dir, recursive); 

                    // Merge the child file sinto our main queue 
                    while(children.Count > 0)
                    {
                        // Copy over each file 
                        fileList.Enqueue(children.Dequeue());
                    }
                }
            }

            // Return our queue 
            return fileList;
        }

        public static bool isScannable(string filePath)
        {
            // Check agaisnt all scannable file types 
            foreach(string ext in Settings.ScannableFiles)
            {
                // Check if the extension is a valid file that we can scan 
                if(filePath.ToLower().EndsWith(ext))
                {
                    // Return true 
                    return true; 
                }
            }

            // No match was found... probably not a scannable file 
            return false; 
        }
    }
}
