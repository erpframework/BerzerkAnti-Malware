using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

//new...
using BerzerkAPI.Analyzers;
using BerzerkAPI.Controllers;
using BerzerkAPI.Models;

//Also new... 
using System.IO;
namespace BerzerkAPI.IO
{
    /*
     * Name: File Libaray 
     * Date: 12/10/2016
     * Developer:Jordan Hook
     * Description: 
     *              The file library provides various functions to perform scans and collect information 
     *              about files systems. 
     */ 
    public static class File
    {
        private static object locker = new object(); 

        /// <summary>
        /// Performs a scan on the provided file
        /// </summary>
        /// <param name="filePath">The file to scan.</param>
        /// <param name="Signatures">The signature controller</param>
        /// <param name="cached">The cache controller</param>
        /// <returns>Null or a signature</returns>
        public static ScanResultArgs ScanFile(string filePath, ref SignatureController Signatures)
        {
            try
            {
                // Final args to return
                var args = new ScanResultArgs(); 

                // *** NEW ***
                // Create a new filestream to read the file with 
                FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read);

                // Before performing any kind of scan, we need to make sure it's a executable file 
                if (!isScannable(filePath))
                {
                    // If it's not, return null and theres no point of scanning it 
                    //return null; 
                    return new ScanResultArgs() { Detection = null, Size = fs.Length };
                }

                // Determine if the file is too large to scan based on settings 
                if (fs.Length > Settings.MaxFileSize)
                {
                    // If so, just return null... 
                    return new ScanResultArgs() { Detection = null, Size = fs.Length };
                }

                // ***********


                // Some local variables to store scan information in 
                byte[] hash = MD5.quickMD5(filePath); 

                // If a cache database is supplied with the scan request 
                //if (cached != null)
                //{
                //    // Try to obtain a md5 hash from the file (see exception below for possible issues) 
                //    //hash = MD5.FromFile(ref fs);
                //    hash = MD5.quickMD5(filePath); 
                    
                //    // Check the file cache to see if the file has already been scanned 
                //    var found = cached.GetById(hash); 

                //    // If a cached item was found in the db
                //    if(found != null)
                //    {
                //        // Return the matching signature if any... 
                //        //return Signatures.GetById(found.SignatureId); 
                //        return new ScanResultArgs() { Detection = Signatures.GetById(found.SignatureId), Size = fs.Length, Cached = found };
                //    }
                //}

                // Either the file cache database is not being used or no entry was found 
                // So we must perform a new scan on the file

                // Determine architecture 
                int _buffer = 32; 
                if(Environment.Is64BitOperatingSystem)
                {
                    _buffer = 64;
                }

                byte[] buffer = new byte[1024 * _buffer]; // Scan in 32kb increments 
                int read = -1; // count how many bytes have been read on each read here 

                // Make sure our buffer isn't bigger than the file 
                if(buffer.Length > fs.Length)
                {
                    // If it is, resize the buffer accordinly 
                    buffer = new byte[fs.Length]; 
                }

                // While there is data to read in the file stream 
                while(read != 0)
                {
                    // Attempt to read the buffered amount.. 
                    read = fs.Read(buffer, 0, buffer.Length);

                    // If the buffered amount if greater than the amount read... 
                    // Lets shrink buffer to speed up the pattern search 
                    if(read < buffer.Length)
                    {
                        Array.Resize(ref buffer, read); 
                    }

                    // Analyze the buffer with the pattern analyzer 
                    var result = PatternAnalyzer.AnalyzeByteArray(buffer, Signatures); 

                    // try version 2.... 
                    //var result = PatternAnalyzer.AnyalyzeByteArrayv2(buffer, Signatures); 

                    // If the result is not null... a detection was found 
                    if(result != null)
                    { 
                        // Create args before closing 
                        args = new ScanResultArgs()
                        {
                            Detection = result,
                            Size = fs.Length,
                        };

                        // We already detected the threat so we do not need to read any more..
                        fs.Dispose();

                        // return the threat
                        return args;
                    }
                }

                // We finished reading the file and no threat was detected 
                // Time to clean and and may be log to cache 

                // Create clean args
                args = new ScanResultArgs() {
                    Detection = null, Size = 
                    fs.Length,
                };


                // Close up the file stream
                fs.Close();
                fs.Dispose();

                // clear buffer 
                buffer = null; 

                // Return a clean scan 
                return args;

            }
            catch (Exception ex) // for debugging purposes
            {
#if DEBUG
                Console.WriteLine(ex.Message);
#endif
                // Throw an exception with info about what may have caused the error. 
                throw new Exception(String.Format("[2] Unable to scan file at location {0}. File may be use or additional rights may be required.", filePath)); 
                //return new ScanResultArgs() { Detection = null, Size = 0 };
            }
        }

        /// <summary>
        /// Generates a queue of files
        /// </summary>
        /// <param name="root">The initial directory of the queue</param>
        /// <param name="recursive">Do you want to search folders within the root directoy</param>
        /// <returns>A queue of files to scan </returns>
        public static Queue<string> CreateFileQueue(string root, bool recursive, Queue<string> fileList = null)
        {
            // If no file list was provided... 
            if(fileList == null)
            {
                // Create a new one... 
                fileList = new Queue<string>();
            }

            try
            {
                // Get all files in the initial directory 
                foreach (string file in Directory.GetFiles(root))
                {
                    // Add each of the files to the queue 
                    fileList.Enqueue(file);
                }
            }
            catch (Exception ex)
            {
#if DEBUG
                Console.WriteLine(ex.Message);
#endif
            }

            // Check if we are to check all the child directories as well 
            if(recursive)
            {
                try
                {
                    // Get all the directories in the root dir 
                    foreach (string dir in Directory.GetDirectories(root))
                    {
                        // Create a queue with al the child directories 
                        Queue<string> children = CreateFileQueue(dir, recursive);

                        // Merge the child file sinto our main queue 
                        while (children.Count > 0)
                        {
                            // Copy over each file 
                            fileList.Enqueue(children.Dequeue());
                        }
                    }
                }
                catch(Exception ex)
                {
#if DEBUG
                    Console.WriteLine(ex.Message);
#endif
                }
            }

            // Return our queue 
            return fileList;
        }

        public static bool isScannable(string filePath)
        {
            //// Check agaisnt all scannable file types 
            //foreach(string ext in Settings.ScannableFiles)
            //{
            //    // Check if the extension is a valid file that we can scan 
            //    if(filePath.ToLower().EndsWith(ext))
            //    {
            //        // Return true 
            //        return true; 
            //    }
            //}

            //// No match was found... probably not a scannable file 
            //return false; 
            if (!filePath.Contains("."))
                return false; 

            string ext = filePath.ToLower().Remove(0, filePath.LastIndexOf("."));

            if (ext.Length == 0)
                return false; 
            else 
                return Settings.ScannableFiles.Contains(ext);
        }

        public static bool DeleteFile(string filePath)
        {
            // Try to delete the file using win32 api 
            if(API.NativeMethods.DeleteFile(filePath))
            {
                // If file deletes return true... 
                return true; 
            }
            else
            {
                // Try to delete file on reboot 
                API.NativeMethods.MoveFileEx(filePath, string.Empty, API.NativeMethods.MoveFileFlags.DelayUntilReboot);

                // Failed to delete, but will try again on reboot... you should probably restart your system 
                return false; 
            }
        }
    }

    public struct ScanResultArgs
    {
        public decimal Size { get; set; }
        public Signature Detection { get; set; }
    }
}
