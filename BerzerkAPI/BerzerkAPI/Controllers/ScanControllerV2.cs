//using BerzerkAPI.API;
//using BerzerkAPI.IO;
//using BerzerkAPI.Models;
//using System;
//using System.Collections.Generic;
//using System.IO;
//using System.Linq;
//using System.Text;
//using System.Threading;
//using System.Threading.Tasks;

//namespace BerzerkAPI.Controllers
//{
//    public class ScanController
//    {
//        /// <summary>
//        /// A queue of file paths that the scan controller is attempting to scan 
//        /// </summary>
//        public Queue<string> TargetFiles { get; set; }
//        public Queue<System.Diagnostics.Process> TargetProcess { get; set; }

//        /// <summary>
//        /// Signature controller with current signature database 
//        /// </summary>
//        public SignatureController Signatures { get; private set; }

//        /// <summary>
//        /// The maximum number of threads the scanner is allowed to use
//        /// </summary>
//        public int MaxThreads { get; set; }

//        /// <summary>
//        /// Determines if the scans should pause
//        /// </summary>
//        public bool Pause { get; set; }

//        /// <summary>
//        /// Used to cancel and abort currently running threads 
//        /// </summary>
//        private bool Cancel { get; set; }

//        /// <summary>
//        /// Returns if the scanner has been cancelled or not 
//        /// </summary>
//        public bool Cancelled { get { return Cancel; } }

//        /// <summary>
//        /// Returns true if a scan is currently in progress. 
//        /// </summary>
//        public bool Scanning { get { return TargetFiles.Count > 0 || RunningThreads > 0 || TargetProcess.Count > 0; } }

//        /// <summary>
//        /// Returns the amount of scan threads currently running 
//        /// </summary>
//        public int RunningThreads { get { return ScannerThreads.Count; } }

//        public decimal ScannedData { get; set; }

//        /// <summary>
//        /// List of threads running 
//        /// </summary>
//        private List<Thread> ScannerThreads { get; set; }

//        private object locker = new object();

//        /// <summary>
//        /// Creates an instance of a new scan controller
//        /// </summary>
//        /// <param name="targetFiles">The files you want to scan</param>
//        /// <param name="signatures">The signature controller to scan with</param>
//        /// <param name="cache">The cache controller to log results with</param>
//        public ScanController(Queue<string> targetFiles, SignatureController signatures)
//        {
//            // Pass the parameters 
//            this.TargetFiles = targetFiles;
//            this.Signatures = signatures;

//            // Initiaize private properties 
//            this.ScannerThreads = new List<Thread>();

//            // Set some defaults
//            this.MaxThreads = Environment.ProcessorCount;
//            this.Pause = false;
//            this.Cancel = false;
//        }

//        public void Run()
//        {
//            // We will run the scan on a new thread 
//            Thread t = new Thread(() =>
//            {
//                bool loadProcess = false; 
//                // While the scan has not been cancelled.. 
//                while(!Cancel)
//                {
//                    // Don't do anything for at least half a second before starting the scan stuff again 
//                    while(Pause && !Cancel)
//                    {
//                        Thread.Sleep(500); 
//                    }

//                    // Check if all queue items have been scanned 
//                    if(RunningThreads == 0 && TargetFiles.Count() == 0 && TargetProcess.Count() == 0)
//                    {
//                        // Annouce scan has been completed 
//                        ThreatScanComplete?.Invoke(this);

//                        // Exit the scan loop ? 
//                        break; 
//                    }
//                    else
//                    {
//                        // There is still work to be done... 
//                        doFileQueue();

//                    }
//                }
//            });

//            t.IsBackground = true; 
//            t.Start();
//        }
        
//        private void doFileQueue()
//        {
//            // while there are files left to scan... 
//            while(TargetFiles.Count > 0)
//            {
//                try
//                {
//                    // Get the next file to scan 
//                    string target = TargetFiles.Dequeue();

//                    // Create read only fs. 
//                    FileStream fs = new FileStream(target, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
//                    byte[] buffer = new byte[1024 * Settings.BufferSize];
//                    int read = -1;

//                    // Make sure our buffer isn't bigger than the file 
//                    if (buffer.Length > fs.Length)
//                    {
//                        // If it is, resize the buffer accordinly 
//                        buffer = new byte[fs.Length];
//                    }

//                    // While there is more data to read... 
//                    while(read != 0 && fs != null)
//                    {
//                        // get the next buffer 
//                        read = fs.Read(buffer, 0, buffer.Length);
                        
//                        // wait for a thread spot to be available 
//                        while(ScannerThreads.Count == MaxThreads)
//                        {
//                            foreach (Thread t in ScannerThreads)
//                            {
//                                if (t.ThreadState == ThreadState.Stopped)
//                                {
//                                    ScannerThreads.Remove(t);
//                                }
//                            }
//                        }

                        

//                        Thread scan = new Thread(() =>
//                        {
//                            // Scan the data 
//                            var result = Analyzers.PatternAnalyzer.AnalyzeByteArray(buffer, Signatures); 

//                            if(result != null)
//                            {
//                                var args = new ScanResultArgs()
//                                {
//                                    Detection = result,
//                                    Size = fs.Length
//                                };


//                                // check for packing 
//                                if(result.Definition == "PACKED")
//                                {
//                                    // unpack the upx packer 
//                                    string unpacked = API.UPXHelper.UnpackFile(target);

//                                    // run scan on unpacked file 
//                                    args = IO.File.ScanFile(unpacked, Signatures);

//                                    // delete unpacked file 
//                                    IO.File.DeleteFile(unpacked);

//                                    // remove unpacked from white list 
//                                    Settings.WhiteList.Remove(unpacked); 
//                                }

//                                // check if a real threat was detected now..
//                                if(args.Detection != null && fs != null)
//                                {
//                                    ThreatDetected?.Invoke(this, new ThreatDetectedArgs()
//                                    {
//                                        Detection = args.Detection,
//                                        FilePath = target
//                                    });

//                                    fs.Dispose();
//                                    fs = null; 
//                                }

//                            }
//                        });

//                        // Setup and start the scan thread 
//                        scan.IsBackground = true;
//                        ScannerThreads.Add(scan);
//                        scan.Start(); 
//                    } // end of while read != 0? 

//                    // wait for all threads to finish ? 
//                    foreach(Thread t in ScannerThreads)
//                    {
//                        t.Join();
//                        ScannerThreads.Remove(t);
//                    }

//                    buffer = null;
//                    fs.Dispose(); 

//                    GC.Collect(); 

//                }
//                catch (Exception ex)
//                {
//                    // access denied probably 
//                }
//            }
//        }


//        /// <summary>
//        /// Cancels the scan 
//        /// </summary>
//        public void Stop()
//        {
//            this.Cancel = true;
//        }

//        /// <summary>
//        /// Triggered when a new threat is detected
//        /// </summary>
//        /// <param name="sender">Source scan controller</param>
//        /// <param name="args">Information about the threat being detected</param>
//        public delegate void ThreatDetectedHandler(ScanController sender, ThreatDetectedArgs args);

//        /// <summary>
//        /// Event triggered when a threat is detected during the scan process. 
//        /// </summary>
//        public event ThreatDetectedHandler ThreatDetected;

//        /// <summary>
//        /// Triggers when the scan has completed. 
//        /// </summary>
//        /// <param name="sender">The scanner that was running.</param>
//        public delegate void ThreatScanCompleteHandler(ScanController sender);
//        /// <summary>
//        /// Triggers when the threat scan has completed 
//        /// </summary>
//        public event ThreatScanCompleteHandler ThreatScanComplete;
//    }

//    /// <summary>
//    /// Information to be included with detection events 
//    /// </summary>
//    public class ThreatDetectedArgs
//    {
//        /// <summary>
//        /// The file location of the detected threat
//        /// </summary>
//        public string FilePath { get; set; }

//        /// <summary>
//        /// The matching signature to the detection 
//        /// </summary>
//        public Signature Detection { get; set; }
//    }
//}
