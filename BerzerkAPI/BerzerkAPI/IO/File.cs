using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

//new...
using BerzerkAPI.Analyzers;
using BerzerkAPI.Controllers;
using BerzerkAPI.Models;

//Also new... 
using System.IO;
using BerzerkAPI.API;
using System.Threading;

namespace BerzerkAPI.IO
{
    /*
     * Name: File Libaray 
     * Date: 12/10/2016
     * Developer:Jordan Hook
     * Description: 
     *              The file library provides various functions to perform scans and collect information 
     *              about files systems. 
     */ 
    public static class File
    {
        private static object locker = new object();
        /// <summary>
        /// Non referenced file scan 
        /// </summary>
        /// <param name="filePath">File to scan.</param>
        /// <param name="Signatures">Signatures to scan with</param>
        /// <returns>Null or signature matching or found in file. </returns>
        //public static ScanResultArgs ScanFile(string filePath, SignatureController Signatures)
        //{
        //    return ScanFile(filePath, ref Signatures);
        //}

        /// <summary>
        /// Performs a scan on the provided file
        /// </summary>
        /// <param name="filePath">The file to scan.</param>
        /// <param name="Signatures">The signature controller</param>
        /// <param name="cached">The cache controller</param>
        /// <returns>Null or a signature</returns>
        public static ScanResultArgs ScanFile(string filePath, SignatureController Signatures)
        {
            //return ScanFileV2(filePath, Signatures); 

            try
            {
                // Final args to return
                var args = new ScanResultArgs(); 

                // *** NEW ***
                // Create a new filestream to read the file with 
                FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);

                // Before performing any kind of scan, we need to make sure it's a executable file 
                if (!isScannable(filePath))
                {
                    // If it's not, return null and theres no point of scanning it 
                    //return null; 
                    return new ScanResultArgs() { Detection = null, Size = fs.Length };
                }

                // Determine if the file is too large to scan based on settings 
                if (fs.Length > Settings.MaxFileSize)
                {
                    // If so, just return null... 
                    return new ScanResultArgs() { Detection = null, Size = fs.Length };
                }

                // ***********


                // Some local variables to store scan information in 
                //byte[] hash = MD5.quickMD5(filePath); 

                // If a cache database is supplied with the scan request 
                //if (cached != null)
                //{
                //    // Try to obtain a md5 hash from the file (see exception below for possible issues) 
                //    //hash = MD5.FromFile(ref fs);
                //    hash = MD5.quickMD5(filePath); 
                    
                //    // Check the file cache to see if the file has already been scanned 
                //    var found = cached.GetById(hash); 

                //    // If a cached item was found in the db
                //    if(found != null)
                //    {
                //        // Return the matching signature if any... 
                //        //return Signatures.GetById(found.SignatureId); 
                //        return new ScanResultArgs() { Detection = Signatures.GetById(found.SignatureId), Size = fs.Length, Cached = found };
                //    }
                //}

                // Either the file cache database is not being used or no entry was found 
                // So we must perform a new scan on the file
                byte[] buffer = new byte[1024 * Settings.BufferSize]; // Scan in 32kb increments 
                int read = -1; // count how many bytes have been read on each read here 

                // Make sure our buffer isn't bigger than the file 
                if(buffer.Length > fs.Length)
                {
                    // If it is, resize the buffer accordinly 
                    buffer = new byte[fs.Length]; 
                }

                // While there is data to read in the file stream 
                while(read != 0)
                {
                    // Attempt to read the buffered amount.. 
                    read = fs.Read(buffer, 0, buffer.Length);

                    // If the buffered amount if greater than the amount read... 
                    // Lets shrink buffer to speed up the pattern search 
                    if(read < buffer.Length)
                    {
                        Array.Resize(ref buffer, read); 
                    }



                    // Analyze the buffer with the pattern analyzer 
                    var result = PatternAnalyzer.AnalyzeByteArray(buffer, Signatures); 

                    // try version 2.... 
                    //var result = PatternAnalyzer.AnyalyzeByteArrayv2(buffer, Signatures); 

                    // If the result is not null... a detection was found 
                    if(result != null)
                    { 
                        // Create args before closing 
                        args = new ScanResultArgs()
                        {
                            Detection = result,
                            Size = fs.Length,
                        };

                        // Detected upx packing... 
                        if(args.Detection.Definition == "PACKED")
                        {
                            // UPX ISNT WORKING YET 
                            //return new ScanResultArgs() { Detection = null, Size = 0 };

                            // unpack the file and store the unpacked path... 
                            string unpacked = API.UPXHelper.UnpackFile(filePath);

                            // Perform another scan 
                            args = ScanFile(unpacked, Signatures);

                            // this was an unpacked program... 
                            //if(args.Detection != null)
                            //{
                            //    //args.Detection.Definition = args.Detection.Definition + "/UPX";
                            //}

                            // delete the unpacked file 
                            File.DeleteFile(unpacked);

                            // Remove the unpacked file from white lsit 
                            Settings.WhiteList.Remove(unpacked); 
                        }

                        // We already detected the threat so we do not need to read any more..
                        fs.Dispose();

                        // return the threat
                        return args;
                    }
                }

                // We finished reading the file and no threat was detected 
                // Time to clean and and may be log to cache 

                // Create clean args
                args = new ScanResultArgs() {
                    Detection = null,
                    Size = fs.Length,
                };


                // Close up the file stream
                fs.Close();
                fs.Dispose();

                // clear buffer 
                buffer = null; 

                // Return a clean scan 
                return args;

            }
            catch (Exception ex) // for debugging purposes
            {
#if DEBUG
                Console.WriteLine(ex.Message);
#endif
                // Throw an exception with info about what may have caused the error. 
                throw new Exception(String.Format("[2] Unable to scan file at location {0}. File may be use or additional rights may be required.", filePath)); 
                //return new ScanResultArgs() { Detection = null, Size = 0 };
            }
        }

        public static ScanResultArgs ScanFileV2(string filePath, SignatureController signatures)
        {
            try
            {
                // Create a new scan result to return with 
                var args = new ScanResultArgs();

                // open new file stream  
                FileStream fs = new System.IO.FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite); 

                // set file size
                args.Size = fs.Length;

                // Check if scannable file type 
                if(!isScannable(filePath))
                {
                    return new ScanResultArgs() { Detection = null };
                }

                // any other additional checks to perform here 

                // Create variables to load file buffers into 
                //byte[] buffer = new byte[1024 * Settings.BufferSize];
                int read = 1; 

                // check if buffer is bigger than file 
                //if(buffer.Length > fs.Length)
                //{
                    // fix buffer 
                    //buffer = new byte[fs.Length];
                //}

                // Create list of tasks to perform scan on 
                List<ThreadedAnalysis> scans = new List<ThreadedAnalysis>();

                int max = Environment.ProcessorCount; ;
                if (Settings.ReducePriority)
                {
                    max = Environment.ProcessorCount / 2;
                }

                // Loop to read file while possible 
                while (read > 0 && args.Detection == null)
                {
                    // read the file chunk 
                    //read = fs.Read(buffer, 0, buffer.Length);

                    // create new threaded scan of the buffer read 
                    ThreadedAnalysis t = new ThreadedAnalysis();
                    read = fs.Read(t.Buffer, 0, t.Buffer.Length); 
                    scans.Add(t);
                    t.run(signatures); 

                    // we now have to do a check
                    if(scans.Count > max)
                    {
                        // if we have max number of scans running we need to clear up some space 
                        for(int i  = 0; i < scans.Count; i++)
                        {
                            // check if a scan is done... 
                            if(scans[i].Complete)
                            {
                                // if it is, check it's result 
                                if(scans[i].Result != null)
                                {
                                    // copy detection over 
                                    args.Detection = scans[i].Result;
                                    // Detected upx packing... 
                                    if (args.Detection.Definition == "PACKED")
                                    {
                                        // unpack the file and store the unpacked path... 
                                        string unpacked = API.UPXHelper.UnpackFile(filePath);

                                        // Perform another scan 
                                        args = ScanFileV2(unpacked, signatures);

                                        // delete the unpacked file 
                                        File.DeleteFile(unpacked);

                                        // Remove the unpacked file from white lsit 
                                        Settings.WhiteList.Remove(unpacked);
                                    }
                                    return args;
                                }
                                else
                                {
                                    // no detection so clear up the scan list 
                                    scans.Remove(scans[i]); 
                                }
                            }
                        }
                    }
                }

                while(scans.Count > 0)
                {
                    // if we have max number of scans running we need to clear up some space 
                    for (int i = 0; i < scans.Count; i++)
                    {
                        // check if a scan is done... 
                        if (scans[i].Complete)
                        {
                            // if it is, check it's result 
                            if (scans[i].Result != null)
                            {
                                // copy detection over 
                                args.Detection = scans[i].Result;
                                // Detected upx packing... 
                                if (args.Detection.Definition == "PACKED")
                                {
                                    // unpack the file and store the unpacked path... 
                                    string unpacked = API.UPXHelper.UnpackFile(filePath);

                                    // Perform another scan 
                                    args = ScanFileV2(unpacked, signatures);

                                    // delete the unpacked file 
                                    File.DeleteFile(unpacked);

                                    // Remove the unpacked file from white lsit 
                                    Settings.WhiteList.Remove(unpacked);
                                }
                                return args;
                            }
                            else
                            {
                                // no detection so clear up the scan list 
                                scans.Remove(scans[i]);
                            }
                        }
                        else
                        {
                            scans[i].waiting(); 
                        }
                    }
                }

                fs.Dispose();
                //buffer = null;

                // return scan results 
                return args;
            }
            catch (Exception ex)
            {
#if DEBUG
                Console.WriteLine(ex.Message); 
#endif 

                throw new Exception("Unable to scan file at location: " + filePath);
            }
        }

        /// <summary>
        /// Generates a queue of files
        /// </summary>
        /// <param name="root">The initial directory of the queue</param>
        /// <param name="recursive">Do you want to search folders within the root directoy</param>
        /// <returns>A queue of files to scan </returns>
        private static HashSet<string> Roots = new HashSet<string>(); 
        public static Queue<string> CreateFileQueue(string root, bool recursive, Queue<string> fileList = null)
        {
            // If no file list was provided... 
            if(fileList == null)
            {
                // Create a new one... 
                fileList = new Queue<string>();
                Roots.Clear(); 
            }

            // Do not add the same folder more than once... 
            if (Roots.Contains(root))
                return fileList;

            // Add root... 
            Roots.Add(root);

            try
            {
                // Get all files in the initial directory 
                foreach (string file in Directory.GetFiles(root))
                {
                    // *** will be switching key to hashset to improve this function 
                    //if (!fileList.Contains(file))
                    if(!Settings.WhiteList.Contains(file))
                    {
                        // Add each of the files to the queue 
                        fileList.Enqueue(file);
                    }
                }
            }
            catch (Exception ex)
            {
#if DEBUG
                Console.WriteLine(ex.Message);
#endif
            }

            // Check if we are to check all the child directories as well 
            if(recursive)
            {
                try
                {
                    // Get all the directories in the root dir 
                    foreach (string dir in Directory.GetDirectories(root))
                    {
                        if (!Settings.WhiteList.Contains(dir))
                        {
                            // Create a queue with al the child directories 
                            Queue<string> children = CreateFileQueue(dir, recursive);

                            // Merge the child file sinto our main queue 
                            while (children.Count > 0)
                            {
                                // Copy over each file 
                                fileList.Enqueue(children.Dequeue());
                            }
                        }
                    }
                }
                catch(Exception ex)
                {
#if DEBUG
                    Console.WriteLine(ex.Message);
#endif
                }
            }

            // Return our queue 
            return fileList;
        }

        public static bool isScannable(string filePath)
        {
            //// Check agaisnt all scannable file types 
            //foreach(string ext in Settings.ScannableFiles)
            //{
            //    // Check if the extension is a valid file that we can scan 
            //    if(filePath.ToLower().EndsWith(ext))
            //    {
            //        // Return true 
            //        return true; 
            //    }
            //}

            //// No match was found... probably not a scannable file 
            //return false; 
            if (!filePath.Contains("."))
                return false; 

            string ext = filePath.ToLower().Remove(0, filePath.LastIndexOf("."));

            if (ext.Length == 0)
                return false; 
            else 
                return Settings.ScannableFiles.Contains(ext);
        }

        public static bool DeleteFile(string filePath)
        {
            // Try to delete the file using win32 api 
            if(API.NativeMethods.DeleteFile(filePath))
            {
                // If file deletes return true... 
                return true; 
            }
            else
            {
                // Unable to delete file... Check for process... 
                var p = Process.GetByFilePath(filePath);

                if (p != null)
                {
                    bool stop = NativeMethods.KillProcess(p.Id);

                    if (!stop)
                    {
                        // Try to delete file on reboot 
                        bool test = API.NativeMethods.MoveFileEx(filePath, null, API.NativeMethods.MoveFileFlags.DelayUntilReboot);

                        return false; 
                    }
                    else
                    {
                        if(API.NativeMethods.DeleteFile(filePath))
                        {
                            return true; 
                        }
                        else 
                        {
                            bool test = API.NativeMethods.MoveFileEx(filePath, null, API.NativeMethods.MoveFileFlags.DelayUntilReboot);

                            return false; 
                        }
                    }
                }
                else
                {
                    // Try to delete file on reboot 
                    bool test = API.NativeMethods.MoveFileEx(filePath, null, API.NativeMethods.MoveFileFlags.DelayUntilReboot);

                    // Failed to delete, but will try again on reboot... you should probably restart your system 
                    return false;
                } 
            }
        }
    }

    public struct ScanResultArgs
    {
        public decimal Size { get; set; }
        public Signature Detection { get; set; }
    }

    public class ThreadedAnalysis
    {

        public Signature Result { get; set; }
        public byte[] Buffer { get; set; }

        public bool Complete { get; private set; }
        private Thread t { get; set; }

        public ThreadedAnalysis()
        {
            this.Complete = false;
            this.Buffer = new byte[1024 * Settings.BufferSize];
        }
        public void run(SignatureController patterns)
        {
            t = new Thread(() =>
            {
                Result = PatternAnalyzer.AnalyzeByteArray(this.Buffer, patterns);

                this.Buffer = null;
                Complete = true;
            });

            t.IsBackground = true;
            t.SetApartmentState(ApartmentState.MTA);
            t.Start();
        }

        public void waiting()
        {
            t.Join(); 
        }
    }
}
