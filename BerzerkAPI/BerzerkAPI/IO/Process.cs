using BerzerkAPI.Analyzers;
using BerzerkAPI.API;
using BerzerkAPI.Controllers;
using BerzerkAPI.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using static BerzerkAPI.API.NativeMethods;

namespace BerzerkAPI.IO
{
    public class Process
    {

        public object Natives { get; private set; }
        public static Signature ScanProcess(System.Diagnostics.Process process, ref SignatureController Signatures)
        {
            try
            {
                if (process.ProcessName == "runnable")
                {
                    //System.IO.File.WriteAllBytes("dump.txt", buffer);
                    Console.Write("");
                }

                // Get the start address of the main module 
                int regionStart = process.MainModule.EntryPointAddress.ToInt32();
                int regionEnd = 0;

                // Could add multiple module support here ... 

                // for now just get end address
                regionEnd = process.MainModule.ModuleMemorySize;

                // Create variables to read the block 
                byte[] buffer = new byte[regionEnd];
                IntPtr zero = IntPtr.Zero;
                
                // Try to read the section 
                ReadProcessMemory(process.Handle, (IntPtr)regionStart, buffer, (UInt32)buffer.Length, out zero);

                //if (zero != IntPtr.Zero)
                {
                    // Run a scan pass of the buffer 
                    var result = PatternAnalyzer.AnalyzeByteArray(buffer,Signatures); 

                    // Check for results 
                    if(result != null)
                    {
                        return result; 
                    }
                }

                // nothing found 
                return null;    
            }
            catch (Exception ex)
            {
                return null;
            }
            //throw new NotImplementedException(); 
        }

        public static Queue<System.Diagnostics.Process> ProcessQueue()
        {
            Queue<System.Diagnostics.Process> list = new Queue<System.Diagnostics.Process>();

            // Get all running processes... 
            foreach (System.Diagnostics.Process p in System.Diagnostics.Process.GetProcesses())
            {
                // don't add our process.. 
                // This may turn into a list later to ignore a certain set of process... 
                if(p.Id != System.Diagnostics.Process.GetCurrentProcess().Id)
                    list.Enqueue(p);
            }

            // queue of process 
            return list; 
        }


        [DllImport("kernel32.dll")]
        internal static extern void GetSystemInfo(ref SYSTEM_INFO lpSystemInfo);

        [DllImport("kernel32.dll")]
        internal static extern void GetNativeSystemInfo(ref SYSTEM_INFO lpSystemInfo);
        [StructLayout(LayoutKind.Sequential)]
        internal struct SYSTEM_INFO
        {
            public ushort wProcessorArchitecture;
            public ushort wReserved;
            public uint dwPageSize;
            public IntPtr lpMinimumApplicationAddress;
            public IntPtr lpMaximumApplicationAddress;
            public UIntPtr dwActiveProcessorMask;
            public uint dwNumberOfProcessors;
            public uint dwProcessorType;
            public uint dwAllocationGranularity;
            public ushort wProcessorLevel;
            public ushort wProcessorRevision;
        };

        public static System.Diagnostics.Process GetByFilePath(string location)
        {
            var list = System.Diagnostics.Process.GetProcesses();
            location = location.ToLower(); 
            foreach (var p in list)
            {
                if(NativeMethods.GetExecutablePath(p).ToLower() == location)
                {
                    return p;
                }    
            }

            return null;
        }
    }
}
