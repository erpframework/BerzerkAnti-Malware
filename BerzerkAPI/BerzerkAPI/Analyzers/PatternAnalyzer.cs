using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using BerzerkAPI.Models;
using BerzerkAPI.Controllers;

namespace BerzerkAPI.Analyzers
{
    /*
     * Name: PatternAnalyzer
     * Date: 01/10/2016
     * Developer: Jordan Hook 
     * Descroption:
     *              The pattern analzyer is a helper library that contains methods for pattern scanning byte arrays in various types of objects
     *              such as processes and files 
     */
    public class PatternAnalyzer
    {
        /// <summary>
        /// Searches a byte array for matching patterns
        /// </summary>
        /// <param name="data">The byte array to search</param>
        /// <param name="patterns">The list of patterns to search for</param>
        /// <returns>A matching malware signature or null if nothing is found</returns>
        public static Signature AnalyzeByteArray(byte[] data, SignatureController patterns)
        {
            // Get all signatures that are a valid length to search for 
            // Signatures must be less than or equal to the length of data 
            var validSignatures = patterns.Signatures.Where(s => s.Pattern.Length < data.Length);

            // Now loop through all the valid signatures and compare them agaisnt the data looking for a match 
            foreach (Signature s in patterns.Signatures)
            {
                // Based on the size of the pattern, run an appropriate algorithm 
                if (s.Pattern.Length <= 8)
                {
                    // Shorter algorithms will run linear searches 
                    if (LinearSearch(ref data, s.Pattern) != -1)
                        return s;
                }
                // Longer patterns will perform a BoyerMooreSearch 
                else if (SimpleBoyerMooreSearch(data, s.Pattern) != -1)
                    return s;
            }

            // If no matches were found, return null 
            return null;
        }

        /// <summary>
        /// Performs a linear search on an array of data
        /// </summary>
        /// <param name="haystack">The data to search</param>
        /// <param name="needle">The pattern to search for</param>
        /// <returns>First matching index of the pattern or -1 if not found</returns>
        private static int LinearSearch(ref byte[] haystack, byte[] needle)
        {
            // A temporary variable to help searches 
            int startIndex;

            // Loop through every byte in the haystack - the length of the needle (we need to match a full needle to the haystack) 
            for (int i = 0; i < haystack.Length - needle.Length; i++)
            {
                // Check if the first index in the needle matches the current byte of the haystack 
                //if(haystack[i] == needle[0] && haystack[i + (needle.Length - 1)] == needle[needle.Length - 1])

                // Check the middle, begin and end locations for matches 
                if (haystack[i] == needle[0] && haystack[i + (needle.Length / 2)] == needle[needle.Length / 2] && haystack[i + (needle.Length - 1)] == needle[needle.Length - 1])
                //if (QuickMatch(ref haystack, i, ref needle)) // <--  a function I am currently developing 
                {
                    //return i;

                    // Loop through the rest of the needle for a match 
                    for (startIndex = 1; startIndex < needle.Length - 1; startIndex++)
                    {
                        // Check if the current index of the needle is a null / 0, if it is, it's a special byte we can skip 
                        if (needle[startIndex] == 0)
                            continue;
                        // Else, check to see if the needle continues to match the haystack 
                        else if (haystack[i + startIndex] != needle[startIndex])
                            // If the pattern stops matching, break the loop to disrupt the count of matching bytes 
                            //startIndex = needle.Length + 1;
                            break;
                    }

                    // After the check is complete, we need to see if the whole pattern match 
                    // *** - 1 added to needle.length to make up for the adjustment to the for loop (-1), due to the pivots check 
                    if (startIndex == needle.Length - 1)
                        // If we found the correct number of matching bytes... return the index of the match 
                        return i;
                    ////else
                    ////i += startIndex - 1;
                }
            }

            // No match was found, return -1 
            return -1;
        }

        static int SimpleBoyerMooreSearch(byte[] haystack, byte[] needle)
        {
            int[] lookup = new int[256];
            for (int i = 0; i < lookup.Length; i++) { lookup[i] = needle.Length; }

            for (int i = 0; i < needle.Length; i++)
            {
                lookup[needle[i]] = needle.Length - i - 1;
            }

            int index = needle.Length - 1;
            var lastByte = needle.Last();
            while (index < haystack.Length)
            {
                var checkByte = haystack[index];
                if (haystack[index] == lastByte)
                {
                    bool found = true;
                    for (int j = needle.Length - 2; j >= 0; j--)
                    {
                        if (haystack[index - needle.Length + j + 1] != needle[j])
                        {
                            found = false;
                            break;
                        }
                    }

                    if (found)
                        return index - needle.Length + 1;
                    else
                        index++;
                }
                else
                {
                    index += lookup[checkByte];
                }
            }
            return -1;
        }
    }
}
