using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using BerzerkAPI.Models;
using BerzerkAPI.Controllers;

namespace BerzerkAPI.Analyzers
{
    /*
     * Name: PatternAnalyzer
     * Date: 01/10/2016
     * Developer: Jordan Hook 
     * Descroption:
     *              The pattern analzyer is a helper library that contains methods for pattern scanning byte arrays in various types of objects
     *              such as processes and files 
     */ 
    public class PatternAnalyzer
    {
        /// <summary>
        /// Searches a byte array for matching patterns
        /// </summary>
        /// <param name="data">The byte array to search</param>
        /// <param name="patterns">The list of patterns to search for</param>
        /// <returns>A matching malware signature or null if nothing is found</returns>
        public static Signature AnalyzeByteArray(byte[] data, SignatureController patterns)
        {
            // Get all signatures that are a valid length to search for 
            // Signatures must be less than or equal to the length of data 
            var validSignatures = patterns.Signatures.Where(s => s.Pattern.Length < data.Length); 

            // Now loop through all the valid signatures and compare them agaisnt the data looking for a match 
            foreach(Signature s in patterns.Signatures)
            {
                // Check each signature, if it returns anything other then -1, then it's a match 
                if (LinearSearch(ref data, s.Pattern) != -1)
                    // When a match is found, return the signature
                    return s; 
            }

            // If no matches were found, return null 
            return null; 
        }

        /// <summary>
        /// Performs a linear search on an array of data
        /// </summary>
        /// <param name="haystack">The data to search</param>
        /// <param name="needle">The pattern to search for</param>
        /// <returns>First matching index of the pattern or -1 if not found</returns>
        private static int LinearSearch(ref byte[] haystack, byte[] needle)
        {
            // A temporary variable to help searches 
            int startIndex; 

            // Loop through every byte in the haystack - the length of the needle (we need to match a full needle to the haystack) 
            for(int i = 0; i < haystack.Length - needle.Length; i++)
            {
                // Check if the first index in the needle matches the current byte of the haystack 
                if(haystack[i] == needle[0])
                {
                    // Loop through the rest of the needle for a match 
                    for(startIndex = 1; startIndex < needle.Length; startIndex++)
                    {
                        // Check if the current index of the needle is a null / 0, if it is, it's a special byte we can skip 
                        if (needle[startIndex] == 0)
                            continue;
                        // Else, check to see if the needle continues to match the haystack 
                        else if (haystack[i + startIndex] != needle[startIndex])
                            // If the pattern stops matching, break the loop to disrupt the count of matching bytes 
                            break;
                    }

                    // After the check is complete, we need to see if the whole pattern match 
                    if (startIndex == needle.Length)
                        // If we found the correct number of matching bytes... return the index of the match 
                        return i; 
                }
            }

            // No match was found, return -1 
            return -1; 
        }
    }
}
